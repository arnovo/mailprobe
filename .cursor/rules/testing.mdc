---
description: Testing patterns for backend Python tests
globs: backend/tests/**/*.py
alwaysApply: false
---

# Testing Patterns

## Mandatory Rule: Add Tests

**Every commit that touches backend MUST add at least 1 new test.**

The pre-commit hook blocks commits if there aren't more tests than before. This applies to:
- New features → tests covering happy path + edge cases
- Refactors → tests verifying behavior hasn't changed
- Bug fixes → test that reproduces the bug (and now passes)

### Exceptions (how to skip)

Only for changes that **don't affect logic**:
- Typos in messages/comments
- Format/style changes
- Dependency updates without code changes

```bash
# Skip ONLY test count verification (other validations remain active)
SKIP_TEST_COUNT=1 git commit -m "fix(ui): typo in error message"
```

**DON'T use `--no-verify`** except in emergencies, as it skips ALL validations.

---

## Principles

1. **Minimal mocking**: Only mock external I/O (network, SMTP, external APIs)
2. **Real database**: PostgreSQL via testcontainers (SQLite fallback if Docker unavailable)
3. **Factories with Faker**: Generate random realistic test data
4. **Test behavior, not implementation**: Focus on inputs/outputs

---

## Reference Examples

Use these files as templates depending on the test type you need:

### 1. Pure Unit Tests → `test_email_patterns.py`

```python
# tests/test_email_patterns.py
class TestGenerateCandidates:
    def test_handles_compound_names(self):
        """Should handle compound first names."""
        candidates = generate_candidates("John Michael", "Smith", "example.com")
        
        assert len(candidates) > 0
        assert any("john" in c for c in candidates)
```

**Why it's good:**
- No mocks (pure functions, no I/O)
- Descriptive names (`test_handles_compound_names`)
- Docstrings explaining expected behavior
- Covers happy path + edge cases (special chars, spaces, etc.)
- Class structure grouping related tests

### 2. Integration Tests with DB/API → `test_leads_flow.py`

```python
# tests/test_leads_flow.py
class TestLeadsAPI:
    @pytest.mark.asyncio
    async def test_leads_isolation_between_workspaces(self, client, db_session, auth_setup):
        """Leads should be isolated between workspaces."""
        workspace1 = auth_setup["workspace"]
        workspace2 = await create_workspace(db_session, name="Other Workspace")

        await create_lead(db_session, workspace=workspace1, first_name="Lead1")
        await create_lead(db_session, workspace=workspace2, first_name="Lead2")
        await db_session.commit()

        response = await client.get("/v1/leads", headers=auth_setup["headers"])
        lead_names = [lead["first_name"] for lead in response.json()["data"]["items"]]

        assert "Lead1" in lead_names
        assert "Lead2" not in lead_names  # Isolation!
```

**Why it's good:**
- Real DB (not mock) via fixtures
- Factories for data creation: `create_lead`, `create_workspace`
- Security test (isolation between workspaces)
- Reusable fixture `auth_setup` with user + token + headers
- Verifies end-to-end behavior

### 3. Tests with Network Mocks → `test_verification_flow.py` + `mocks.py`

```python
# tests/mocks.py - Reusable fixtures
@pytest.fixture
def mock_dns_valid(monkeypatch):
    """Mock DNS resolver to return valid MX records."""
    def fake_resolve(domain: str, rdtype: str, lifetime: float = None):
        if rdtype == "MX":
            return FakeDNSAnswer([FakeMXRecord(10, f"mail.{domain}.")])
        # ...
    monkeypatch.setattr("dns.resolver.resolve", fake_resolve)

# tests/test_verification_flow.py - Uses the mocks
class TestVerifyEmail:
    def test_valid_email_with_mocked_network(self, mock_dns_valid, mock_smtp_valid):
        """Should validate email with mocked DNS and SMTP."""
        result = verify_email("john.doe@example.com")
        
        assert result.status in ("valid", "risky", "unknown")
        assert result.mx_found
        assert result.smtp_check
```

**Why it's good:**
- Mocks ONLY external I/O (DNS, SMTP) - not internal logic
- Simple and clear Fake classes (`FakeSMTP`, `FakeDNSAnswer`)
- Reusable fixtures in `mocks.py`
- Tests cover: valid, rejected, timeout, catch-all, no MX
- `pytest_plugins = ["tests.mocks"]` to load fixtures

---

## Test Structure

```python
# tests/test_leads.py
import pytest
from tests.factories import LeadFactory

class TestLeadVerification:
    """Group related tests in classes"""
    
    def test_verify_valid_email(self, db_session):
        lead = LeadFactory(email="test@example.com")
        result = verify_lead(lead.id, db_session)
        assert result.status == "valid"
    
    def test_verify_invalid_domain(self, db_session):
        lead = LeadFactory(email="test@nonexistent.invalid")
        result = verify_lead(lead.id, db_session)
        assert result.status == "invalid"
```

## Factories

```python
# tests/factories.py
import factory
from faker import Faker
from app.models import Lead, Workspace

fake = Faker()

class WorkspaceFactory(factory.Factory):
    class Meta:
        model = Workspace
    
    name = factory.LazyAttribute(lambda _: fake.company())

class LeadFactory(factory.Factory):
    class Meta:
        model = Lead
    
    first_name = factory.LazyAttribute(lambda _: fake.first_name())
    last_name = factory.LazyAttribute(lambda _: fake.last_name())
    email = factory.LazyAttribute(lambda _: fake.email())
    workspace = factory.SubFactory(WorkspaceFactory)
```

## Fixtures

```python
# tests/conftest.py uses testcontainers for PostgreSQL
# Automatically uses PostgreSQL if Docker is running, else SQLite fallback

@pytest.fixture
def db_session(db_engine):
    """Async database session (PostgreSQL or SQLite)"""
    # Provided by conftest.py - uses testcontainers when Docker available

@pytest.fixture
def mock_smtp(mocker):
    """Mock SMTP connections"""
    return mocker.patch("app.services.smtp.smtplib.SMTP")
```

## What to Mock

```python
# ✅ Mock external services
mock_smtp = mocker.patch("smtplib.SMTP")
mock_dns = mocker.patch("dns.resolver.resolve")
mock_requests = mocker.patch("requests.get")

# ❌ Don't mock internal logic
# Don't mock: database queries, business logic, utils
```

## Running Tests

```bash
# All tests (auto-detects Docker for PostgreSQL)
pytest tests/ -v

# Force PostgreSQL (requires Docker running)
TEST_USE_POSTGRES=1 pytest tests/ -v

# Specific file
pytest tests/test_leads.py -v

# Stop on first failure
pytest tests/ -x

# With coverage
pytest tests/ --cov=app --cov-report=term-missing
```
